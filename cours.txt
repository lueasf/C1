COURS DE C THÉORIQUE

### Les compilateurs
gcc -o nom_du_fichier nom_du_fichier.c
clang -o nom_du_fichier nom_du_fichier.c


### Makefile
CFLAGS = -std=c99 -Wall -Wextra -pedantic -g3 -fsanitize=address
LDFLAGS = -fsanitize=address
LIBS =
main: main.o module.o
    clang -o main $(LDFLAGS) module.o main.o $(LIBS)
module.o: module.c module.h
    clang -c $(CFLAGS) module.c
main.o: main.c main.h
    clang -c $(CFLAGS) main.c
clean:
    rm -f main *.o


### Les %qqch:
%d pour digits (int et short), 
%ld pour long unsigned, 
%f pour float et double
%.2f pour 2 chiffres après la virgule
%d pour char
%s pour string
%x pour hexadécimal
%p pour l'adresse

-un entier prends en memoire %ld octets (sizeof(entier))
-(float)( a + b) pour caster (changer de type)
-un charactère est aussi un nombre ASCII
-les booleens sont 0 = faux et tous les autres = vrai

&& (et) || (ou)



###Les librairies
stdlib -> pour les fonctions exit, malloc, free, ...
stdio -> pour les fonctions d'entrée/sortie comme printf, scanf, stdin 
math.h -> round, sqrt
// en utilisant sqrt, il faut compiler avec -lm à la fin pour (lib math)

unistd.h -> sleep
time.h -> aléatoire : srand(time(NULL)); rand() % 26 + 65
string.h -> chaine de char (strlen, strcmp(ordre lexicogrp test)),
    strtol (convertit un nombre en str en int).
    strcpy(dans celle la, on copie cette case)



###POINTEURS
C'est un type qui ne contient pas une valeur mais une adresse mémoire. Les tableaux sont des pointeurs.
int a = 5;
int *p = &a; // p pointe vers l'adresse de a ( on dit aussi que p pointe sur a)
&a c'est une adresse, *a c'est la valeur.
OU :
int *p;
p = &a; // on attribue l'adresse de a à p
Les deux sont des alias, on peut donc modifier a en modifiant p.
Reserver dynamiquement de la mémoire :
int *p = (int *)malloc(sizeof(int)); attention malloc renvoie untype void donc on convertit en int*.
D'OU:
p pointeur => *p valeur, p adresse
n non pointeur => n valeur,  &adresse
LOL : un pointeur peut pointer sur un pointeur (ex une matrice).
free(p) pour libérer la mémoire
const int *p; on peut modifier p mais pas *p
int * const p; on peut modifier *p mais pas p
char *s = "hello";
char c = *s; c = 
ascii(\0) = 0!!!



###fonctions
scanf peut lire des caractères individuels et des entiers.
scanf("%d", &var)
fflsuh(stdin) pour vider le buffer de lecture
fgets peut lire des lignes de texte dans un tableau de caractères (char).
fgetc peut lire des caractères individuels à partir d'un flux de fichier.
putchar(' ')
printf(" ")

// int resultat = (2*6 == 32);
// printf(“%d”, resultat);
// ce programme renvoie 0 car 12 != 32
// rappel : 0 est faux et tous les autres sont vrai



####Opérateur ternaire (? :) :
C'est une expression conditionnelle qui permet de réaliser une opération basée sur une condition. 
Sa syntaxe générale est (condition) ? valeur_si_vrai : valeur_si_faux.
EXEMPLE : 
return (n == 0) ? 0 : n + somme(n - 1);
veut dire que si n vaut 0 on renvoie 0 sinon on renvoie n + somme(n-1)



###condition
switch(var){
    case 1:
    printf
    break;
    case2:...
    default:
}



###boucle
FOR : for (int i =0; i<10; i++){}
continue pour passer à l'itération suivante
break pour quitter la boucle 

WHILE : while (condition) {
    // Bloc de code à exécuter tant que la condition est vraie
}
La boucle while teste la condition avant d'exécuter le bloc de 
code à l'intérieur de la boucle. 

DO : do {
    // Bloc de code à exécuter au moins une fois
} while (condition);

Cela garantit que le bloc de code est exécuté au moins une fois, 
meme si la condition est fausse dès le départ.



### TABLEAU
le nom du tableau correspond à l'adresse de sa première case.
int tab[taille] = {,,}
tab[i] = *(tab + 1)
tab -> str : char ch[] = {'o', 'l', 'a', '\0'}; printf("%s",ch);
char *s = "hello"; printf("%s",s);
fgets(tab,taille, stdin)==NULL{return -1}
rappel : LE '\0', C'EST POUR LES STR, PAS LES TABLEAUX
// calcul de la taille d'un tableau d'entier : 
// int tab[] = {1, 2, 3, 4, 5};
// int taille = sizeof(tab) / sizeof(tab[0]);
// tableau de 0 : int tab[10] = {0};

char *s = "hello"; codé en dur
int len = 0;
while (*s != '\0') {
    len++;
    s++;
}


### fonctions
signature : type nom(type1, type2);
fonction main
déclaration de fonction 



### Zones de mémoires
pile : utilisé pour les var locales
zone non modifiable : chaine constante
tas (heap) : utilisé pour aloouer de la mémoire (ex:malloc)



### fichier
int main() {
    FILE *fichier = fopen("chemin/vers/le/fichier.txt", "r");
    char caractere;

    if (fichier == NULL) {
        printf("Impossible d'ouvrir le fichier.\n");
        return 1;
    }

    while ((caractere = fgetc(fichier)) != EOF) {
        printf("%c", caractere);
    }
    OU
    char buffer[100];
    while (fgets(buffer, 100, fichier) != NULL) {
        printf("%s", buffer);
    }

    fclose(fichier);

    return 0;
}


### COMPILATION ET PRÉPROCESSEUR:
zero overhead principle
#include
#define NOM VALEUR , on l'inclut dans le fichier et on peut l'utiliser,
le nom, comme une variable.
#ifdef



### fichiers:
dans mod.c on met la fonction et la DÉFINITION
dans le mod.h on DÉCLARE la fonction
dans le main.c on met la main et on inclut le mod.h



### ???
fscanf(fichier, "%d", &var);
fread
fseek
ftell
rewind
ferror
feof
fclose
fputc
fwrite
fprintf



### STRUCTURES
STRUCT : pour modéliser des données personnalisées: 

struct Array {
    int *tab;
    int size;
};

struct Person {
    char name[50];
    int age;
    char address[100];
};

TYPEDEF utilisé pour définir un alias pour un type de données existant.
typedef struct Person Person;
#maintenant on peut utiliser Person comme un vrai type:
Person p1; qui équivaut à struct Person p1;

On peut combiner les deux : 
typedef struct {
    char name[50];
    int age;
} Person;

p_carte-> fig = rand() % 13 + 1; // permet de générer un nombre entre 1 et 13
// la notation p_carte -> fig est équivalente à (*p_carte).fig 

EXEMPLE :

int main(){
    // Déclaration d'une variable de type Person
    Person person1;
    
    strcpy(person1.name, "John");
    person1.age = 30;

    printf("Nom: %s\n", person1.name);
    printf("Age: %d\n", person1.age);
    
    return 0;
}




### opératinos bits à bits:
0xF7 & 0xAC = 1010 0100 = 0xA4
Les opérateurs << et >> permettent de décaler la
représentation binaire vers la gauche ou la droite
4 << 1 = 0100 << 1 = 1000 = 8
0xF7 << 4 = 0111 0000 = 0x70


### TRUC
#1
int* bad_answer_to_life(void) {
    int answer = 1;
    return &answer;
}
Cette fonction renvoie un pointeur vers un entier qui 
n'existe plus après l'exécution de la fonction. Car la variable
est locale.

#2
int main(void) {
    char *msg = "ooki";
    *msg = 'd';
    printf("%s\n", msg);
}
Cette fonctionne compile pas sans erreur car les chaînes stoquées en 
dur sont en lecture seule.
La solution est d'utiliser un tableau:
int main(void){
    char msg[] = "ooki";
    *msg = 'd';
    printf("%s\n", msg);
}
qui renvoie alors "doki".

#3
int main(void) {
    int tab[3];

    tab[0] = 1;
    tab[1] = 2;
    tab[2] = 3;

    printf("tab = %p\n", tab);
    printf("&tab = %p\n", &tab);
    printf("tab[0] = %d\n", tab[0]);
    printf("&tab[0] = %p\n", &tab[0]);

    int t2[3];
    tab = t2;
}
Ici l'erreur de un problème de type. En effet, tab et t2 sont de memes types
donc la syntaxe est correcte mais la sémantique fait defaut.
L'erreur est un peu nulle, elle ne devrait pas avoir lieu.
On la corrige en mettant *tab = &t2

#4
malloc :
void * malloc( size_t memorySize );

Cette fonction permet d'allouer un bloc de mémoire dans le tas. 
Attention : la mémoire allouée dynamiquement n'est pas automatiquement
relachée. Il faudra donc, après utilisation, libérer ce bloc de 
mémoire via un appel à la fonction free. 
exemple :
int *tab = (int *)malloc(10 * sizeof(int));
ce qui alloue un tableau de 10 entiers.

calloc :
void * calloc( size_t numElements, size_t elementSize );
calloc permet d'allouer un bloc de mémoire et de l'initialiser à 0.
exemple :
int *tab = (int *)calloc(10, sizeof(int));
ce qui alloue un tableau de 10 entiers initialisés à 0.




### CONCEPT:
FUITE MÉMOIRE AKA MEMORY LEAKS:
C'est un problème qui survient lorsqu'un programme alloue de la mémoire
dynamiquement mais ne la libère pas. Cela peut entrainer une utilisation
excessive de la mémoire et des problèmes de performances.
Pour pallier a ce problème on peut utiliser la fonction free qui permet
de libérer la mémoire allouée dynamiquement.
L'option -fsanitize=address détecte ces fuites.


DÉPASSEMENT DE TAMPON AKA OVERFLOW:
C'est un problème qui survient lorsqu'un programme écrit en dehors des
limites d'un tableau. Cela peut entrainer des comportements inattendus
et des problèmes de sécurité. Pour éviter ce problème, il est important
de vérifier les limites du tableau avant d'écrire dedans.
exemple :
int tab[10];
for (int i = 0; i < 11; i++) {
    tab[i] = i;
}
on écrit en dehors des limites du tableau donc problème.



###GDB
voici comment on utilise gdb :
gdb ./nom_du_fichier